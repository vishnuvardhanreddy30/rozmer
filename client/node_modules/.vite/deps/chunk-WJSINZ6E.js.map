{
  "version": 3,
  "sources": ["../../kothing-editor/lib/lib/util.js"],
  "sourcesContent": ["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/*\r\n * KothingEditor\r\n *\r\n * The WYSIWYG Rich Text Editor\r\n * Copyright Kothing.\r\n * MIT license.\r\n */\n\n/**\r\n * @description utility function\r\n */\nvar util = {\n  _d: null,\n  _w: null,\n  isIE: null,\n  isIE_Edge: null,\n  isOSX_IOS: null,\n  _propertiesInit: function _propertiesInit() {\n    if (this._d) return;\n    this._d = document;\n    this._w = window;\n    this.isIE = navigator.userAgent.indexOf(\"Trident\") > -1;\n    this.isIE_Edge = navigator.userAgent.indexOf(\"Trident\") > -1 || navigator.appVersion.indexOf(\"Edge\") > -1;\n    this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform);\n  },\n  _allowedEmptyNodeList: \".ke-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas\",\n\n  /**\r\n   * @description HTML Reserved Word Converter.\r\n   * @param {String} contents\r\n   * @returns {String} HTML string\r\n   * @private\r\n   */\n  _HTMLConvertor: function _HTMLConvertor(contents) {\n    var ec = {\n      \"&\": \"&amp;\",\n      \"\\xA0\": \"&nbsp;\",\n      \"'\": \"&apos;\",\n      '\"': \"&quot;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\"\n    };\n    return contents.replace(/&|\\u00A0|'|\"|<|>/g, function (m) {\n      return typeof ec[m] === \"string\" ? ec[m] : m;\n    });\n  },\n\n  /**\r\n   * @description Unicode Character 'ZERO WIDTH SPACE' (\\u200B)\r\n   */\n  zeroWidthSpace: String.fromCharCode(8203),\n\n  /**\r\n   * @description Regular expression to find 'zero width space' (/\\u200B/g)\r\n   */\n  zeroWidthRegExp: new RegExp(String.fromCharCode(8203), \"g\"),\n\n  /**\r\n   * @description Regular expression to find only 'zero width space' (/^\\u200B+$/)\r\n   */\n  onlyZeroWidthRegExp: new RegExp(\"^\" + String.fromCharCode(8203) + \"+$\"),\n\n  /**\r\n   * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)\r\n   * @param {String|Node} text String value or Node\r\n   * @returns {Boolean}\r\n   */\n  onlyZeroWidthSpace: function onlyZeroWidthSpace(text) {\n    if (typeof text !== \"string\") text = text.textContent;\n    return text === \"\" || this.onlyZeroWidthRegExp.test(text);\n  },\n\n  /**\r\n   * @description Gets XMLHttpRequest object\r\n   * @returns {XMLHttpRequest|ActiveXObject}\r\n   */\n  getXMLHttpRequest: function getXMLHttpRequest() {\n    /** IE */\n    if (this._w.ActiveXObject) {\n      try {\n        return new ActiveXObject(\"Msxml2.XMLHTTP\");\n      } catch (e) {\n        try {\n          return new ActiveXObject(\"Microsoft.XMLHTTP\");\n        } catch (e1) {\n          return null;\n        }\n      }\n    } else if (this._w.XMLHttpRequest) {\n      /** netscape */\n      return new XMLHttpRequest();\n    } else {\n      /** fail */\n      return null;\n    }\n  },\n\n  /**\r\n   * @description Create Element node\r\n   * @param {String} elementName Element name\r\n   * @returns {Element}\r\n   */\n  createElement: function createElement(elementName) {\n    return this._d.createElement(elementName);\n  },\n\n  /**\r\n   * @description Create text node\r\n   * @param {String} text text contents\r\n   * @returns {Node}\r\n   */\n  createTextNode: function createTextNode(text) {\n    return this._d.createTextNode(text || \"\");\n  },\n\n  /**\r\n   * @description The editor checks tags by string.\r\n   * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n   * When using an attribute with \"<\" or \">\", use \"HTMLEncoder\" to save. (ex: math(katex))\r\n   * @param {String} contents HTML or Text string\r\n   * @returns {String}\r\n   */\n  HTMLEncoder: function HTMLEncoder(contents) {\n    var ec = {\n      \"<\": \"$lt;\",\n      \">\": \"$gt;\"\n    };\n    return contents.replace(/<|>/g, function (m) {\n      return typeof ec[m] === \"string\" ? ec[m] : m;\n    });\n  },\n\n  /**\r\n   * @description The editor checks tags by string.\r\n   * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n   * Decoder of data stored as \"HTMLEncoder\" (ex: math(katex))\r\n   * @param {String} contents HTML or Text string\r\n   * @returns {String}\r\n   */\n  HTMLDecoder: function HTMLDecoder(contents) {\n    var ec = {\n      \"$lt;\": \"<\",\n      \"$gt;\": \">\"\n    };\n    return contents.replace(/\\$lt;|\\$gt;/g, function (m) {\n      return typeof ec[m] === \"string\" ? ec[m] : m;\n    });\n  },\n\n  /**\r\n   * @description This method run Object.prototype.hasOwnProperty.call(obj, key)\r\n   * @param {Object} obj Object\r\n   * @param {String} key obj.key\r\n   * @returns {Boolean}\r\n   */\n  hasOwn: function hasOwn(obj, key) {\n    return this._hasOwn.call(obj, key);\n  },\n  _hasOwn: Object.prototype.hasOwnProperty,\n\n  /**\r\n   * @deprecated\r\n   * @description Get the the tag path of the arguments value\r\n   * If not found, return the first found value\r\n   * @param {Array} nameArray File name array\r\n   * @param {String} extension js, css\r\n   * @returns {String}\r\n   */\n  getIncludePath: function getIncludePath(nameArray, extension) {\n    var path = \"\";\n    var pathList = [];\n    var tagName = extension === \"js\" ? \"script\" : \"link\";\n    var src = extension === \"js\" ? \"src\" : \"href\";\n    var fileName = \"(?:\";\n\n    for (var i = 0, len = nameArray.length; i < len; i++) {\n      fileName += nameArray[i] + (i < len - 1 ? \"|\" : \")\");\n    }\n\n    var regExp = new this._w.RegExp(\"(^|.*[\\\\/])\" + fileName + \"(\\\\.[^\\\\/]+)?.\" + extension + \"(?:\\\\?.*|;.*)?$\", \"i\");\n    var extRegExp = new this._w.RegExp(\".+\\\\.\" + extension + \"(?:\\\\?.*|;.*)?$\", \"i\");\n\n    for (var c = this._d.getElementsByTagName(tagName), _i = 0; _i < c.length; _i++) {\n      if (extRegExp.test(c[_i][src])) {\n        pathList.push(c[_i]);\n      }\n    }\n\n    for (var _i2 = 0; _i2 < pathList.length; _i2++) {\n      var editorTag = pathList[_i2][src].match(regExp);\n\n      if (editorTag) {\n        path = editorTag[0];\n        break;\n      }\n    }\n\n    if (path === \"\") path = pathList.length > 0 ? pathList[0][src] : \"\";\n    -1 === path.indexOf(\":/\") && \"//\" !== path.slice(0, 2) && (path = 0 === path.indexOf(\"/\") ? location.href.match(/^.*?:\\/\\/[^\\/]*/)[0] + path : location.href.match(/^[^\\?]*\\/(?:)/)[0] + path);\n    if (!path) throw \"[KothingEditor.util.getIncludePath.fail] The KothingEditor installation path could not be automatically detected. (name: +\" + name + \", extension: \" + extension + \")\";\n    return path;\n  },\n\n  /**\r\n   * @deprecated\r\n   * @description Returns the CSS text that has been applied to the current page.\r\n   * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.\r\n   * @returns {String} Styles string\r\n   */\n  getPageStyle: function getPageStyle(doc) {\n    var cssText = \"\";\n    var sheets = (doc || this._d).styleSheets;\n\n    for (var i = 0, len = sheets.length, rules; i < len; i++) {\n      try {\n        rules = sheets[i].cssRules;\n      } catch (e) {\n        continue;\n      }\n\n      if (rules) {\n        for (var c = 0, cLen = rules.length; c < cLen; c++) {\n          cssText += rules[c].cssText;\n        }\n      }\n    }\n\n    return cssText;\n  },\n\n  /**\r\n   * @description Get the argument iframe's document object\r\n   * @param {Element} iframe Iframe element (context.element.wysiwygFrame)\r\n   * @returns {Document}\r\n   */\n  getIframeDocument: function getIframeDocument(iframe) {\n    var wDocument = iframe.contentWindow || iframe.contentDocument;\n    if (wDocument.document) wDocument = wDocument.document;\n    return wDocument;\n  },\n\n  /**\r\n   * @description Get attributes of argument element to string ('class=\"---\" name=\"---\" ')\r\n   * @param {Element} element Element object\r\n   * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result\r\n   * @returns {String}\r\n   */\n  getAttributesToString: function getAttributesToString(element, exceptAttrs) {\n    if (!element.attributes) return \"\";\n    var attrs = element.attributes;\n    var attrString = \"\";\n\n    for (var i = 0, len = attrs.length; i < len; i++) {\n      if (exceptAttrs && exceptAttrs.indexOf(attrs[i].name) > -1) continue;\n      attrString += attrs[i].name + '=\"' + attrs[i].value + '\" ';\n    }\n\n    return attrString;\n  },\n\n  /**\r\n   * @descriptionGets Get the length in bytes of a string.\r\n   * referencing code: \"https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11\"\r\n   * @param {String} text String text\r\n   * @returns {Number}\r\n   */\n  getByteLength: function getByteLength(text) {\n    if (!text || !text.toString) return 0;\n    text = text.toString();\n    var encoder = this._w.encodeURIComponent;\n    var cr, cl;\n\n    if (this.isIE_Edge) {\n      cl = this._w.unescape(encoder(text)).length;\n      cr = 0;\n\n      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\n        cr = encoder(text).match(/(%0A|%0D)/gi).length;\n      }\n\n      return cl + cr;\n    } else {\n      cl = new this._w.TextEncoder(\"utf-8\").encode(text).length;\n      cr = 0;\n\n      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\n        cr = encoder(text).match(/(%0A|%0D)/gi).length;\n      }\n\n      return cl + cr;\n    }\n  },\n\n  /**\r\n   * @description It is judged whether it is the edit region top div element or iframe's body tag.\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isWysiwygDiv: function isWysiwygDiv(element) {\n    return element && element.nodeType === 1 && (this.hasClass(element, \"ke-wrapper-wysiwyg\") || /^BODY$/i.test(element.nodeName));\n  },\n\n  /**\r\n   * @description It is judged whether it is the contenteditable property is false.\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isNonEditable: function isNonEditable(element) {\n    return element && element.nodeType === 1 && element.getAttribute(\"contenteditable\") === \"false\";\n  },\n\n  /**\r\n   * @description It is judged whether it is a node related to the text style.\r\n   * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isTextStyleElement: function isTextStyleElement(element) {\n    return element && element.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)$/i.test(element.nodeName);\n  },\n\n  /**\r\n   * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class=\"__ke__format__replace_xxx\")\r\n   * Format element also contain \"free format Element\"\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isFormatElement: function isFormatElement(element) {\n    return element && element.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD)$/i.test(element.nodeName) || this.hasClass(element, \"(\\\\s|^)__ke__format__replace_.+(\\\\s|$)|(\\\\s|^)__ke__format__free_.+(\\\\s|$)\")) && !this.isComponent(element) && !this.isWysiwygDiv(element);\n  },\n\n  /**\r\n   * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class=\"__ke__format__range_xxx\")\r\n   * Range format element is wrap the \"format element\" and \"component\"\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isRangeFormatElement: function isRangeFormatElement(element) {\n    return element && element.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(element.nodeName) || this.hasClass(element, \"(\\\\s|^)__ke__format__range_.+(\\\\s|$)\"));\n  },\n\n  /**\r\n   * @description It is judged whether it is the closure range format element. (TH, TD | class=\"__ke__format__range__closure_xxx\")\r\n   * Closure range format elements is included in the range format element.\r\n   *  - Closure range format element is wrap the \"format element\" and \"component\"\r\n   * \u203B You cannot exit this format with the Enter key or Backspace key.\r\n   * \u203B Use it only in special cases. ([ex] format of table cells)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isClosureRangeFormatElement: function isClosureRangeFormatElement(element) {\n    return element && element.nodeType === 1 && (/^(TH|TD)$/i.test(element.nodeName) || this.hasClass(element, \"(\\\\s|^)__ke__format__range__closure_.+(\\\\s|$)\"));\n  },\n\n  /**\r\n   * @description It is judged whether it is the free format element. (PRE | class=\"__ke__format__free_xxx\")\r\n   * Free format elements is included in the format element.\r\n   * Free format elements's line break is \"BR\" tag.\r\n   * \u203B Entering the Enter key in the space on the last line ends \"Free Format\" and appends \"Format\".\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isFreeFormatElement: function isFreeFormatElement(element) {\n    return element && element.nodeType === 1 && (/^PRE$/i.test(element.nodeName) || this.hasClass(element, \"(\\\\s|^)__ke__format__free_.+(\\\\s|$)\")) && !this.isComponent(element) && !this.isWysiwygDiv(element);\n  },\n\n  /**\r\n   * @description It is judged whether it is the closure free format element. (class=\"__ke__format__free__closure_xxx\")\r\n   * Closure free format elements is included in the free format element.\r\n   *  - Closure free format elements's line break is \"BR\" tag.\r\n   * \u203B You cannot exit this format with the Enter key or Backspace key.\r\n   * \u203B Use it only in special cases. ([ex] format of table cells)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isClosureFreeFormatElement: function isClosureFreeFormatElement(element) {\n    return element && element.nodeType === 1 && this.hasClass(element, \"(\\\\s|^)__ke__format__free__closure_.+(\\\\s|$)\");\n  },\n\n  /**\r\n   * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class=\"ke-component\") and table, hr\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isComponent: function isComponent(element) {\n    return element && (/ke-component/.test(element.className) || /^(TABLE|HR)$/.test(element.nodeName));\n  },\n\n  /**\r\n   * @description Checks for \"__ke__uneditable\" in the class list.\r\n   * Components with class \"__ke__uneditable\" cannot be modified.\r\n   * @param {Element} element The element to check\r\n   * @returns {Boolean}\r\n   */\n  isUneditableComponent: function isUneditableComponent(element) {\n    return element && this.hasClass(element, \"__ke__uneditable\");\n  },\n\n  /**\r\n   * @description It is judged whether it is the component [img, iframe] cover(class=\"ke-component\")\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isMediaComponent: function isMediaComponent(element) {\n    return element && /ke-component/.test(element.className);\n  },\n\n  /**\r\n   * @description It is judged whether it is the not checking node. (class=\"katex\", \"__ke__tag\")\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isNotCheckingNode: function isNotCheckingNode(element) {\n    return element && /katex|__ke__tag/.test(element.className);\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getFormatElement: function getFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isRangeFormatElement(element)) element.firstElementChild;\n      if (this.isFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getRangeFormatElement: function getRangeFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isRangeFormatElement(element) && !/^(THEAD|TBODY|TR)$/i.test(element.nodeName) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getFreeFormatElement: function getFreeFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isFreeFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getClosureFreeFormatElement: function getClosureFreeFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isClosureFreeFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description Add style and className of copyEl to originEl\r\n   * @param {Element} originEl Origin element\r\n   * @param {Element} copyEl Element to copy\r\n   */\n  copyTagAttributes: function copyTagAttributes(originEl, copyEl) {\n    if (copyEl.style.cssText) {\n      originEl.style.cssText += copyEl.style.cssText;\n    }\n\n    var classes = copyEl.classList;\n\n    for (var i = 0, len = classes.length; i < len; i++) {\n      this.addClass(originEl, classes[i]);\n    }\n\n    if (!originEl.style.cssText) originEl.removeAttribute(\"style\");\n    if (!originEl.className.trim()) originEl.removeAttribute(\"class\");\n  },\n\n  /**\r\n   * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore \"__ke__format__\" class\r\n   * @param {Element} originEl Origin element\r\n   * @param {Element} copyEl Element to copy\r\n   */\n  copyFormatAttributes: function copyFormatAttributes(originEl, copyEl) {\n    copyEl = copyEl.cloneNode(false);\n    copyEl.className = copyEl.className.replace(/(\\s|^)__ke__format__[^\\s]+/g, \"\");\n    this.copyTagAttributes(originEl, copyEl);\n  },\n\n  /**\r\n   * @description Get the item from the array that matches the condition.\r\n   * @param {Array|HTMLCollection|NodeList} array Array to get item\r\n   * @param {Function|null} validation Conditional function\r\n   * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.\r\n   * If false, returns only one item that meet the criteria otherwise return null.\r\n   * @returns {Array|Node|null}\r\n   */\n  getArrayItem: function getArrayItem(array, validation, multi) {\n    if (!array || array.length === 0) return null;\n\n    validation = validation || function () {\n      return true;\n    };\n\n    var arr = [];\n\n    for (var i = 0, len = array.length, a; i < len; i++) {\n      a = array[i];\n\n      if (validation(a)) {\n        if (!multi) return a;else arr.push(a);\n      }\n    }\n\n    return !multi ? null : arr;\n  },\n\n  /**\r\n   * @description Get the index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} element The element to find index\r\n   * @returns {Number}\r\n   */\n  getArrayIndex: function getArrayIndex(array, element) {\n    var idx = -1;\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === element) {\n        idx = i;\n        break;\n      }\n    }\n\n    return idx;\n  },\n\n  /**\r\n   * @description Get the next index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} item The element to find index\r\n   * @returns {Number}\r\n   */\n  nextIdx: function nextIdx(array, item) {\n    var idx = this.getArrayIndex(array, item);\n    if (idx === -1) return -1;\n    return idx + 1;\n  },\n\n  /**\r\n   * @description Get the previous index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array Element array\r\n   * @param {Node} item The element to find index\r\n   * @returns {Number}\r\n   */\n  prevIdx: function prevIdx(array, item) {\n    var idx = this.getArrayIndex(array, item);\n    if (idx === -1) return -1;\n    return idx - 1;\n  },\n\n  /**\r\n   * @description Returns the index compared to other sibling nodes.\r\n   * @param {Node} node The Node to find index\r\n   * @returns {Number}\r\n   */\n  getPositionIndex: function getPositionIndex(node) {\n    var idx = 0;\n\n    while (node = node.previousSibling) {\n      idx += 1;\n    }\n\n    return idx;\n  },\n\n  /**\r\n   * @description Returns the position of the \"node\" in the \"parentNode\" in a numerical array.\r\n   * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: \"bb\", parentNode: \"<P>\") -> [1, 0]\r\n   * @param {Node} node The Node to find position path\r\n   * @param {Node|null} parentNode Parent node. If null, wysiwyg div area\r\n   * @param {Object|null} _newOffsets If you send an object of the form \"{s: 0, e: 0}\", the text nodes that are attached together are merged into one, centered on the \"node\" argument.\r\n   * \"_newOffsets.s\" stores the length of the combined characters after \"node\" and \"_newOffsets.e\" stores the length of the combined characters before \"node\".\r\n   * Do not use unless absolutely necessary.\r\n   * @returns {Array}\r\n   */\n  getNodePath: function getNodePath(node, parentNode, _newOffsets) {\n    var path = [];\n    var finds = true;\n    this.getParentElement(node, function (el) {\n      if (el === parentNode) finds = false;\n\n      if (finds && !this.isWysiwygDiv(el)) {\n        // merge text nodes\n        if (_newOffsets && el.nodeType === 3) {\n          var temp = null,\n              tempText = null;\n          _newOffsets.s = _newOffsets.e = 0;\n          var previous = el.previousSibling;\n\n          while (previous && previous.nodeType === 3) {\n            tempText = previous.textContent.replace(this.zeroWidthRegExp, \"\");\n            _newOffsets.s += tempText.length;\n            el.textContent = tempText + el.textContent;\n            temp = previous;\n            previous = previous.previousSibling;\n            this.removeItem(temp);\n          }\n\n          var next = el.nextSibling;\n\n          while (next && next.nodeType === 3) {\n            tempText = next.textContent.replace(this.zeroWidthRegExp, \"\");\n            _newOffsets.e += tempText.length;\n            el.textContent += tempText;\n            temp = next;\n            next = next.nextSibling;\n            this.removeItem(temp);\n          }\n        } // index push\n\n\n        path.push(el);\n      }\n\n      return false;\n    }.bind(this));\n    return path.map(this.getPositionIndex).reverse();\n  },\n\n  /**\r\n   * @description Returns the node in the location of the path array obtained from \"util.getNodePath\".\r\n   * @param {Array} offsets Position array, array obtained from \"util.getNodePath\"\r\n   * @param {Node} parentNode Base parent element\r\n   * @returns {Node}\r\n   */\n  getNodeFromPath: function getNodeFromPath(offsets, parentNode) {\n    var current = parentNode;\n    var nodes;\n\n    for (var i = 0, len = offsets.length; i < len; i++) {\n      nodes = current.childNodes;\n      if (nodes.length === 0) break;\n\n      if (nodes.length <= offsets[i]) {\n        current = nodes[nodes.length - 1];\n      } else {\n        current = nodes[offsets[i]];\n      }\n    }\n\n    return current;\n  },\n\n  /**\r\n   * @description Compares the style and class for equal values.\r\n   * Returns true if both are text nodes.\r\n   * @param {Node} a Node to compare\r\n   * @param {Node} b Node to compare\r\n   * @returns {Boolean}\r\n   */\n  isSameAttributes: function isSameAttributes(a, b) {\n    if (a.nodeType === 3 && b.nodeType === 3) return true;\n    if (a.nodeType === 3 || b.nodeType === 3) return false;\n    var style_a = a.style;\n    var style_b = b.style;\n    var compStyle = 0;\n\n    for (var i = 0, len = style_a.length; i < len; i++) {\n      if (style_a[style_a[i]] === style_b[style_a[i]]) compStyle++;\n    }\n\n    var class_a = a.classList;\n    var class_b = b.classList;\n    var reg = this._w.RegExp;\n    var compClass = 0;\n\n    for (var _i3 = 0, _len = class_a.length; _i3 < _len; _i3++) {\n      if (reg(\"(s|^)\" + class_a[_i3] + \"(s|$)\").test(class_b.value)) compClass++;\n    }\n\n    return compStyle === style_b.length && compStyle === style_a.length && compClass === class_b.length && compClass === class_a.length;\n  },\n\n  /**\r\n   * @description Check the line element(util.isFormatElement) is empty.\r\n   * @param {Element} element Format element node\r\n   * @returns {Boolean}\r\n   */\n  isEmptyLine: function isEmptyLine(element) {\n    return !element || !element.parentNode || !element.querySelector(\"IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE\") && this.onlyZeroWidthSpace(element.textContent);\n  },\n\n  /**\r\n   * @description Check the node is a list (ol, ul)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isList: function isList(node) {\n    return node && /^(OL|UL)$/i.test(typeof node === \"string\" ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a list cell (li)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isListCell: function isListCell(node) {\n    return node && /^LI$/i.test(typeof node === \"string\" ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a table (table, thead, tbody, tr, th, td)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isTable: function isTable(node) {\n    return node && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof node === \"string\" ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a table cell (td, th)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isCell: function isCell(node) {\n    return node && /^(TD|TH)$/i.test(typeof node === \"string\" ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a break node (BR)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isBreak: function isBreak(node) {\n    return node && /^BR$/i.test(typeof node === \"string\" ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a anchor node (A)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isAnchor: function isAnchor(node) {\n    return node && /^A$/i.test(typeof node === \"string\" ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a media node (img, iframe, audio, video, canvas)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isMedia: function isMedia(node) {\n    return node && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof node === \"string\" ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Checks for numeric (with decimal point).\r\n   * @param {String|Number} text Text string or number\r\n   * @returns {Boolean}\r\n   */\n  isNumber: function isNumber(text) {\n    return !!text && /^-?\\d+(\\.\\d+)?$/.test(text + \"\");\n  },\n\n  /**\r\n   * @description Get a number.\r\n   * @param {String|Number} text Text string or number\r\n   * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)\r\n   * @returns {Number}\r\n   */\n  getNumber: function getNumber(text, maxDec) {\n    if (!text) return 0;\n    var number = (text + \"\").match(/-?\\d+(\\.\\d+)?/);\n    if (!number || !number[0]) return 0;\n    number = number[0];\n    return maxDec < 0 ? number * 1 : maxDec === 0 ? this._w.Math.round(number * 1) : (number * 1).toFixed(maxDec) * 1;\n  },\n\n  /**\r\n   * @description Get all \"children\" of the argument value element (Without text nodes)\r\n   * @param {Element} element element to get child node\r\n   * @param {Function|null} validation Conditional function\r\n   * @returns {Array}\r\n   */\n  getListChildren: function getListChildren(element, validation) {\n    var children = [];\n    if (!element || !element.children || element.children.length === 0) return children;\n\n    validation = validation || function () {\n      return true;\n    };\n\n    (function recursionFunc(current) {\n      if (element !== current && validation(current)) {\n        children.push(current);\n      }\n\n      if (!!current.children) {\n        for (var i = 0, len = current.children.length; i < len; i++) {\n          recursionFunc(current.children[i]);\n        }\n      }\n    })(element);\n\n    return children;\n  },\n\n  /**\r\n   * @description Get all \"childNodes\" of the argument value element (Include text nodes)\r\n   * @param {Node} element element to get child node\r\n   * @param {Function|null} validation Conditional function\r\n   * @returns {Array}\r\n   */\n  getListChildNodes: function getListChildNodes(element, validation) {\n    var children = [];\n    if (!element || element.childNodes.length === 0) return children;\n\n    validation = validation || function () {\n      return true;\n    };\n\n    (function recursionFunc(current) {\n      if (element !== current && validation(current)) {\n        children.push(current);\n      }\n\n      for (var i = 0, len = current.childNodes.length; i < len; i++) {\n        recursionFunc(current.childNodes[i]);\n      }\n    })(element);\n\n    return children;\n  },\n\n  /**\r\n   * @description Returns the number of parents nodes.\r\n   * \"0\" when the parent node is the WYSIWYG area.\r\n   * \"-1\" when the element argument is the WYSIWYG area.\r\n   * @param {Node} element The element to check\r\n   * @returns {Number}\r\n   */\n  getElementDepth: function getElementDepth(element) {\n    if (!element || this.isWysiwygDiv(element)) return -1;\n    var depth = 0;\n    element = element.parentNode;\n\n    while (element && !this.isWysiwygDiv(element)) {\n      depth += 1;\n      element = element.parentNode;\n    }\n\n    return depth;\n  },\n\n  /**\r\n   * @description Compares two elements to find a common ancestor, and returns the order of the two elements.\r\n   * @param {Node} a Node to compare.\r\n   * @param {Node} b Node to compare.\r\n   * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };\r\n   */\n  compareElements: function compareElements(a, b) {\n    var aNode = a,\n        bNode = b;\n\n    while (aNode && bNode && aNode.parentNode !== bNode.parentNode) {\n      aNode = aNode.parentNode;\n      bNode = bNode.parentNode;\n    }\n\n    if (!aNode || !bNode) return {\n      ancestor: null,\n      a: a,\n      b: b,\n      result: 0\n    };\n    var children = aNode.parentNode.childNodes;\n    var aIndex = this.getArrayIndex(children, aNode);\n    var bIndex = this.getArrayIndex(children, bNode);\n    return {\n      ancestor: aNode.parentNode,\n      a: aNode,\n      b: bNode,\n      result: aIndex > bIndex ? 1 : aIndex < bIndex ? -1 : 0\n    };\n  },\n\n  /**\r\n   * @description Get the parent element of the argument value.\r\n   * A tag that satisfies the query condition is imported.\r\n   * Returns null if not found.\r\n   * @param {Node} element Reference element\r\n   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n   * Not use it like jquery.\r\n   * Only one condition can be entered at a time.\r\n   * @returns {Element|null}\r\n   */\n  getParentElement: function getParentElement(element, query) {\n    var check;\n\n    if (typeof query === \"function\") {\n      check = query;\n    } else {\n      var attr;\n\n      if (/^\\./.test(query)) {\n        attr = \"className\";\n        query = query.split(\".\")[1];\n      } else if (/^#/.test(query)) {\n        attr = \"id\";\n        query = \"^\" + query.split(\"#\")[1] + \"$\";\n      } else if (/^:/.test(query)) {\n        attr = \"name\";\n        query = \"^\" + query.split(\":\")[1] + \"$\";\n      } else {\n        attr = \"nodeName\";\n        query = \"^\" + query + \"$\";\n      }\n\n      var regExp = new this._w.RegExp(query, \"i\");\n\n      check = function check(el) {\n        return regExp.test(el[attr]);\n      };\n    }\n\n    while (element && !check(element)) {\n      if (this.isWysiwygDiv(element)) {\n        return null;\n      }\n\n      element = element.parentNode;\n    }\n\n    return element;\n  },\n\n  /**\r\n   * @description Get the child element of the argument value.\r\n   * A tag that satisfies the query condition is imported.\r\n   * Returns null if not found.\r\n   * @param {Node} element Reference element\r\n   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n   * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)\r\n   * Not use it like jquery.\r\n   * Only one condition can be entered at a time.\r\n   * @returns {Element|null}\r\n   */\n  getChildElement: function getChildElement(element, query, last) {\n    var check;\n\n    if (typeof query === \"function\") {\n      check = query;\n    } else {\n      var attr;\n\n      if (/^\\./.test(query)) {\n        attr = \"className\";\n        query = query.split(\".\")[1];\n      } else if (/^#/.test(query)) {\n        attr = \"id\";\n        query = \"^\" + query.split(\"#\")[1] + \"$\";\n      } else if (/^:/.test(query)) {\n        attr = \"name\";\n        query = \"^\" + query.split(\":\")[1] + \"$\";\n      } else {\n        attr = \"nodeName\";\n        query = \"^\" + (query === \"text\" ? \"#\" + query : query) + \"$\";\n      }\n\n      var regExp = new this._w.RegExp(query, \"i\");\n\n      check = function check(el) {\n        return regExp.test(el[attr]);\n      };\n    }\n\n    var childList = this.getListChildNodes(element, function (current) {\n      return check(current);\n    });\n    return childList[last ? childList.length - 1 : 0];\n  },\n\n  /**\r\n   * @description 1. The first node of all the child nodes of the \"first\" element is returned.\r\n   * 2. The last node of all the child nodes of the \"last\" element is returned.\r\n   * 3. When there is no \"last\" element, the first and last nodes of all the children of the \"first\" element are returned.\r\n   * { sc: \"first\", ec: \"last\" }\r\n   * @param {Node} first First element\r\n   * @param {Node|null} last Last element\r\n   * @returns {Object}\r\n   */\n  getEdgeChildNodes: function getEdgeChildNodes(first, last) {\n    if (!first) return;\n    if (!last) last = first;\n\n    while (first && first.nodeType === 1 && first.childNodes.length > 0 && !this.isBreak(first)) {\n      first = first.firstChild;\n    }\n\n    while (last && last.nodeType === 1 && last.childNodes.length > 0 && !this.isBreak(last)) {\n      last = last.lastChild;\n    }\n\n    return {\n      sc: first,\n      ec: last || first\n    };\n  },\n\n  /**\r\n   * @description Returns the position of the left and top of argument. {left:0, top:0}\r\n   * @param {Node} element Target node\r\n   * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)\r\n   * @returns {Object}\r\n   */\n  getOffset: function getOffset(element, wysiwygFrame) {\n    var offsetLeft = 0;\n    var offsetTop = 0;\n    var offsetElement = element.nodeType === 3 ? element.parentElement : element;\n    var wysiwyg = this.getParentElement(element, this.isWysiwygDiv.bind(this));\n\n    while (offsetElement && !this.hasClass(offsetElement, \"ke-container\") && offsetElement !== wysiwyg) {\n      offsetLeft += offsetElement.offsetLeft;\n      offsetTop += offsetElement.offsetTop;\n      offsetElement = offsetElement.offsetParent;\n    }\n\n    var iframe = wysiwygFrame && /iframe/i.test(wysiwygFrame.nodeName);\n    return {\n      left: offsetLeft + (iframe ? wysiwygFrame.parentElement.offsetLeft : 0),\n      top: offsetTop - (wysiwyg ? wysiwyg.scrollTop : 0) + (iframe ? wysiwygFrame.parentElement.offsetTop : 0)\n    };\n  },\n\n  /**\r\n   * @description It compares the start and end indexes of \"a\" and \"b\" and returns the number of overlapping indexes in the range.\r\n   * ex) 1, 5, 4, 6 => \"2\" (4 ~ 5)\r\n   * @param {Number} aStart Start index of \"a\"\r\n   * @param {Number} aEnd End index of \"a\"\r\n   * @param {Number} bStart Start index of \"b\"\r\n   * @param {Number} bEnd Start index of \"b\"\r\n   * @returns {Number}\r\n   */\n  getOverlapRangeAtIndex: function getOverlapRangeAtIndex(aStart, aEnd, bStart, bEnd) {\n    if (aStart <= bEnd ? aEnd < bStart : aEnd > bStart) return 0;\n    var overlap = (aStart > bStart ? aStart : bStart) - (aEnd < bEnd ? aEnd : bEnd);\n    return (overlap < 0 ? overlap * -1 : overlap) + 1;\n  },\n\n  /**\r\n   * @description Set the text content value of the argument value element\r\n   * @param {Node} element Element to replace text content\r\n   * @param {String} txt Text to be applied\r\n   */\n  changeTxt: function changeTxt(element, txt) {\n    if (!element || !txt) return;\n    element.textContent = txt;\n  },\n\n  /**\r\n   * @description Replace element\r\n   * @param {Element} element Target element\r\n   * @param {String|Element} newElement String or element of the new element to apply\r\n   */\n  changeElement: function changeElement(element, newElement) {\n    if (typeof newElement === \"string\") {\n      if (element.outerHTML) {\n        element.outerHTML = newElement;\n      } else {\n        var doc = this.createElement(\"DIV\");\n        doc.innerHTML = newElement;\n        newElement = doc.firstChild;\n        element.parentNode.replaceChild(newElement, element);\n      }\n    } else if (newElement.nodeType === 1) {\n      element.parentNode.replaceChild(newElement, element);\n    }\n  },\n\n  /**\r\n   * @description Set style, if all styles are deleted, the style properties are deleted.\r\n   * @param {Element} element Element to set style\r\n   * @param {String} styleName Style attribute name (marginLeft, textAlign...)\r\n   * @param {String|Number} value Style value\r\n   */\n  setStyle: function setStyle(element, styleName, value) {\n    element.style[styleName] = value;\n\n    if (!value && !element.style.cssText) {\n      element.removeAttribute(\"style\");\n    }\n  },\n\n  /**\r\n   * @description Determine whether any of the matched elements are assigned the given class\r\n   * @param {Element} element Elements to search class name\r\n   * @param {String} className Class name to search for\r\n   * @returns {Boolean}\r\n   */\n  hasClass: function hasClass(element, className) {\n    if (!element) return;\n    return new this._w.RegExp(className).test(element.className);\n  },\n\n  /**\r\n   * @description Append the className value of the argument value element\r\n   * @param {Element} element Elements to add class name\r\n   * @param {String} className Class name to be add\r\n   */\n  addClass: function addClass(element, className) {\n    if (!element) return;\n    var check = new this._w.RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\");\n    if (check.test(element.className)) return;\n    element.className += (element.className.length > 0 ? \" \" : \"\") + className;\n  },\n\n  /**\r\n   * @description Delete the className value of the argument value element\r\n   * @param {Element} element Elements to remove class name\r\n   * @param {String} className Class name to be remove\r\n   */\n  removeClass: function removeClass(element, className) {\n    if (!element) return;\n    var check = new this._w.RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\");\n    element.className = element.className.replace(check, \" \").trim();\n    if (!element.className.trim()) element.removeAttribute(\"class\");\n  },\n\n  /**\r\n   * @description Argument value If there is no class name, insert it and delete the class name if it exists\r\n   * @param {Element} element Elements to replace class name\r\n   * @param {String} className Class name to be change\r\n   * @returns {Boolean|undefined}\r\n   */\n  toggleClass: function toggleClass(element, className) {\n    if (!element) return;\n    var result = false;\n    var check = new this._w.RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\");\n\n    if (check.test(element.className)) {\n      element.className = element.className.replace(check, \" \").trim();\n    } else {\n      element.className += \" \" + className;\n      result = true;\n    }\n\n    if (!element.className.trim()) element.removeAttribute(\"class\");\n    return result;\n  },\n\n  /**\r\n   * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.\r\n   * core.codeViewDisabledButtons (An array of buttons whose class name is not \"ke-code-view-enabled\")\r\n   * core.resizingDisabledButtons (An array of buttons whose class name is not \"ke-resizing-enabled\")\r\n   * @param {Boolean} disabled Disabled value\r\n   * @param {Array|HTMLCollection|NodeList} toolbarItem Button array\r\n   */\n  setDisabledButtons: function setDisabledButtons(disabled, toolbarItem) {\n    for (var i = 0, len = toolbarItem.length; i < len; i++) {\n      toolbarItem[i].disabled = disabled;\n    }\n  },\n\n  /**\r\n   * @description Delete argumenu value element\r\n   * @param {Node} item Node to be remove\r\n   */\n  removeItem: function removeItem(item) {\n    if (!item) return;\n    if (typeof item.remove === \"function\") item.remove();else if (item.parentNode) item.parentNode.removeChild(item);\n  },\n\n  /**\r\n   * @description Delete all parent nodes that match the condition.\r\n   * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.\r\n   * @param {Node} item Node to be remove\r\n   * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)\r\n   * @param {Element|null} stopParent Stop when the parent node reaches stopParent\r\n   * @returns {Object|null} {sc: previousSibling, ec: nextSibling}\r\n   */\n  removeItemAllParents: function removeItemAllParents(item, validation, stopParent) {\n    if (!item) return null;\n    var cc = null;\n\n    if (!validation) {\n      validation = function (current) {\n        if (current === stopParent || this.isComponent(current)) return false;\n        var text = current.textContent.trim();\n        return text.length === 0 || /^(\\n|\\u200B)+$/.test(text);\n      }.bind(this);\n    }\n\n    (function recursionFunc(element) {\n      if (!util.isWysiwygDiv(element)) {\n        var parent = element.parentNode;\n\n        if (parent && validation(element)) {\n          cc = {\n            sc: element.previousElementSibling,\n            ec: element.nextElementSibling\n          };\n          util.removeItem(element);\n          recursionFunc(parent);\n        }\n      }\n    })(item);\n\n    return cc;\n  },\n\n  /**\r\n   * @description Detach Nested all nested lists under the \"baseNode\".\r\n   * Returns a list with nested removed.\r\n   * @param {Node} baseNode Element on which to base.\r\n   * @param {Boolean} all If true, it also detach all nested lists of a returned list.\r\n   * @returns {Element}\r\n   */\n  detachNestedList: function detachNestedList(baseNode, all) {\n    var rNode = this._deleteNestedList(baseNode);\n\n    var rangeElement, cNodes;\n\n    if (rNode) {\n      rangeElement = rNode.cloneNode(false);\n      cNodes = rNode.childNodes;\n      var index = this.getPositionIndex(baseNode);\n\n      while (cNodes[index]) {\n        rangeElement.appendChild(cNodes[index]);\n      }\n    } else {\n      rangeElement = baseNode;\n    }\n\n    var rChildren;\n\n    if (!all) {\n      var depth = this.getElementDepth(baseNode) + 2;\n      rChildren = this.getListChildren(baseNode, function (current) {\n        return this.isListCell(current) && !current.previousElementSibling && this.getElementDepth(current) === depth;\n      }.bind(this));\n    } else {\n      rChildren = this.getListChildren(rangeElement, function (current) {\n        return this.isListCell(current) && !current.previousElementSibling;\n      }.bind(this));\n    }\n\n    for (var i = 0, len = rChildren.length; i < len; i++) {\n      this._deleteNestedList(rChildren[i]);\n    }\n\n    if (rNode) {\n      rNode.parentNode.insertBefore(rangeElement, rNode.nextSibling);\n      if (cNodes && cNodes.length === 0) this.removeItem(rNode);\n    }\n\n    return rangeElement === baseNode ? rangeElement.parentNode : rangeElement;\n  },\n\n  /**\r\n   * @description Sub function of util.detachNestedList method.\r\n   * @private\r\n   */\n  _deleteNestedList: function _deleteNestedList(baseNode) {\n    var baseParent = baseNode.parentNode;\n    var sibling = baseParent;\n    var parent = sibling.parentNode;\n    var liSibling, liParent, child, index, c;\n\n    while (this.isListCell(parent)) {\n      index = this.getPositionIndex(baseNode);\n      liSibling = parent.nextElementSibling;\n      liParent = parent.parentNode;\n      child = sibling;\n\n      while (child) {\n        sibling = sibling.nextSibling;\n\n        if (this.isList(child)) {\n          c = child.childNodes;\n\n          while (c[index]) {\n            liParent.insertBefore(c[index], liSibling);\n          }\n\n          if (c.length === 0) this.removeItem(child);\n        } else {\n          liParent.appendChild(child);\n        }\n\n        child = sibling;\n      }\n\n      sibling = liParent;\n      parent = liParent.parentNode;\n    }\n\n    if (baseParent.children.length === 0) this.removeItem(baseParent);\n    return liParent;\n  },\n\n  /**\r\n   * @description Split all tags based on \"baseNode\"\r\n   * Returns the last element of the splited tag.\r\n   * @param {Node} baseNode Element or text node on which to base\r\n   * @param {Number|null} offset Text offset of \"baseNode\" (Only valid when \"baseNode\" is a text node)\r\n   * @param {Number} depth The nesting depth of the element being split. (default: 0)\r\n   * @returns {Element}\r\n   */\n  splitElement: function splitElement(baseNode, offset, depth) {\n    var bp = baseNode.parentNode;\n    var index = 0,\n        newEl,\n        children,\n        temp;\n    var next = true;\n    if (!depth || depth < 0) depth = 0;\n\n    if (baseNode.nodeType === 3) {\n      index = this.getPositionIndex(baseNode);\n\n      if (offset >= 0) {\n        baseNode.splitText(offset);\n        var after = this.getNodeFromPath([index + 1], bp);\n        if (this.onlyZeroWidthSpace(after)) after.data = this.zeroWidthSpace;\n      }\n    } else if (baseNode.nodeType === 1) {\n      if (!baseNode.previousSibling) {\n        if (this.getElementDepth(baseNode) === depth) next = false;\n      } else {\n        baseNode = baseNode.previousSibling;\n      }\n    }\n\n    var depthEl = baseNode;\n\n    while (this.getElementDepth(depthEl) > depth) {\n      index = this.getPositionIndex(depthEl) + 1;\n      depthEl = depthEl.parentNode;\n      temp = newEl;\n      newEl = depthEl.cloneNode(false);\n      children = depthEl.childNodes;\n\n      if (temp) {\n        if (this.isListCell(newEl) && this.isList(temp) && temp.firstElementChild) {\n          newEl.innerHTML = temp.firstElementChild.innerHTML;\n          util.removeItem(temp.firstElementChild);\n          if (temp.children.length > 0) newEl.appendChild(temp);\n        } else {\n          newEl.appendChild(temp);\n        }\n      }\n\n      while (children[index]) {\n        newEl.appendChild(children[index]);\n      }\n    }\n\n    if (depthEl.childNodes.length <= 1 && (!depthEl.firstChild || depthEl.firstChild.textContent.length === 0)) depthEl.innerHTML = \"<br>\";\n    var pElement = depthEl.parentNode;\n    if (next) depthEl = depthEl.nextSibling;\n    if (!newEl) return depthEl;\n    this.mergeSameTags(newEl, null, false);\n    this.mergeNestedTags(newEl, function (current) {\n      return this.isList(current);\n    }.bind(this));\n    if (newEl.childNodes.length > 0) pElement.insertBefore(newEl, depthEl);else newEl = depthEl;\n    if (bp.childNodes.length === 0) this.removeItem(bp);\n    return newEl;\n  },\n\n  /**\r\n   * @description Use with \"npdePath (util.getNodePath)\" to merge the same attributes and tags if they are present and modify the nodepath.\r\n   * If \"offset\" has been changed, it will return as much \"offset\" as it has been modified.\r\n   * An array containing change offsets is returned in the order of the \"nodePathArray\" array.\r\n   * @param {Element} element Element\r\n   * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])\r\n   * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.\r\n   * @returns {Array} [offset, ..]\r\n   */\n  mergeSameTags: function mergeSameTags(element, nodePathArray, onlyText) {\n    var inst = this;\n    var nodePathLen = nodePathArray ? nodePathArray.length : 0;\n    var offsets = null;\n\n    if (nodePathLen) {\n      offsets = this._w.Array.apply(null, new this._w.Array(nodePathLen)).map(this._w.Number.prototype.valueOf, 0);\n    }\n\n    (function recursionFunc(current, depth, depthIndex) {\n      var children = current.childNodes;\n\n      for (var i = 0, len = children.length, child, next; i < len; i++) {\n        child = children[i];\n        next = children[i + 1];\n        if (!child) break;\n\n        if (onlyText && inst._isIgnoreNodeChange(child) || !onlyText && (inst.isTable(child) || inst.isListCell(child) || inst.isFormatElement(child) && !inst.isFreeFormatElement(child))) {\n          if (inst.isTable(child) || inst.isListCell(child)) {\n            recursionFunc(child, depth + 1, i);\n          }\n\n          continue;\n        }\n\n        if (len === 1 && current.nodeName === child.nodeName && current.parentNode) {\n          // update nodePath\n          if (nodePathLen) {\n            var path = void 0,\n                c = void 0,\n                p = void 0,\n                cDepth = void 0,\n                spliceDepth = void 0;\n\n            for (var n = 0; n < nodePathLen; n++) {\n              path = nodePathArray[n];\n\n              if (path && path[depth] === i) {\n                c = child, p = current, cDepth = depth, spliceDepth = true;\n\n                while (cDepth >= 0) {\n                  if (inst.getArrayIndex(p.childNodes, c) !== path[cDepth]) {\n                    spliceDepth = false;\n                    break;\n                  }\n\n                  c = child.parentNode;\n                  p = c.parentNode;\n                  cDepth--;\n                }\n\n                if (spliceDepth) {\n                  path.splice(depth, 1);\n                  path[depth] = i;\n                }\n              }\n            }\n          } // merge tag\n\n\n          inst.copyTagAttributes(child, current);\n          current.parentNode.insertBefore(child, current);\n          inst.removeItem(current);\n        }\n\n        if (!next) {\n          if (child.nodeType === 1) recursionFunc(child, depth + 1, i);\n          break;\n        }\n\n        if (child.nodeName === next.nodeName && inst.isSameAttributes(child, next) && child.href === next.href) {\n          var childs = child.childNodes;\n          var childLength = 0;\n\n          for (var _n = 0, nLen = childs.length; _n < nLen; _n++) {\n            if (childs[_n].textContent.length > 0) childLength++;\n          }\n\n          var l = child.lastChild;\n          var r = next.firstChild;\n          var addOffset = 0;\n\n          if (l && r) {\n            var textOffset = l.nodeType === 3 && r.nodeType === 3;\n            addOffset = l.textContent.length;\n            var tempL = l.previousSibling;\n\n            while (tempL && tempL.nodeType === 3) {\n              addOffset += tempL.textContent.length;\n              tempL = tempL.previousSibling;\n            }\n\n            if (childLength > 0 && l.nodeType === 3 && r.nodeType === 3 && (l.textContent.length > 0 || r.textContent.length > 0)) childLength--;\n\n            if (nodePathLen) {\n              var _path = null;\n\n              for (var _n2 = 0; _n2 < nodePathLen; _n2++) {\n                _path = nodePathArray[_n2];\n\n                if (_path && _path[depth] > i) {\n                  if (depth > 0 && _path[depth - 1] !== depthIndex) continue;\n                  _path[depth] -= 1;\n\n                  if (_path[depth + 1] >= 0 && _path[depth] === i) {\n                    _path[depth + 1] += childLength;\n\n                    if (textOffset) {\n                      if (l && l.nodeType === 3 && r && r.nodeType === 3) {\n                        offsets[_n2] += addOffset;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          if (child.nodeType === 3) {\n            addOffset = child.textContent.length;\n            child.textContent += next.textContent;\n\n            if (nodePathLen) {\n              var _path2 = null;\n\n              for (var _n3 = 0; _n3 < nodePathLen; _n3++) {\n                _path2 = nodePathArray[_n3];\n\n                if (_path2 && _path2[depth] > i) {\n                  if (depth > 0 && _path2[depth - 1] !== depthIndex) continue;\n                  _path2[depth] -= 1;\n\n                  if (_path2[depth + 1] >= 0 && _path2[depth] === i) {\n                    _path2[depth + 1] += childLength;\n                    offsets[_n3] += addOffset;\n                  }\n                }\n              }\n            }\n          } else {\n            child.innerHTML += next.innerHTML;\n          }\n\n          inst.removeItem(next);\n          i--;\n        } else if (child.nodeType === 1) {\n          recursionFunc(child, depth + 1, i);\n        }\n      }\n    })(element, 0, 0);\n\n    return offsets;\n  },\n\n  /**\r\n   * @description Remove nested tags without other child nodes.\r\n   * @param {Element} element Element object\r\n   * @param {Function|String|null} validation Validation function / String(\"tag1|tag2..\") / If null, all tags are applicable.\r\n   */\n  mergeNestedTags: function mergeNestedTags(element, validation) {\n    if (typeof validation === \"string\") {\n      validation = function (current) {\n        return this.test(current.tagName);\n      }.bind(new this._w.RegExp(\"^(\" + (validation ? validation : \".+\") + \")$\", \"i\"));\n    } else if (typeof validation !== \"function\") {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    (function recursionFunc(current) {\n      var children = current.children;\n\n      if (children.length === 1 && children[0].nodeName === current.nodeName && validation(current)) {\n        var temp = children[0];\n        children = temp.children;\n\n        while (children[0]) {\n          current.appendChild(children[0]);\n        }\n\n        current.removeChild(temp);\n      }\n\n      for (var i = 0, len = current.children.length; i < len; i++) {\n        recursionFunc(current.children[i]);\n      }\n    })(element);\n  },\n\n  /**\r\n   * @description Delete a empty child node of argument element\r\n   * @param {Element} element Element node\r\n   * @param {Node|null} notRemoveNode Do not remove node\r\n   */\n  removeEmptyNode: function removeEmptyNode(element, notRemoveNode) {\n    var inst = this;\n\n    if (notRemoveNode) {\n      notRemoveNode = inst.getParentElement(notRemoveNode, function (current) {\n        return element === current.parentElement;\n      });\n    }\n\n    (function recursionFunc(current) {\n      if (inst._notTextNode(current) || current === notRemoveNode || inst.isNonEditable(current)) return 0;\n\n      if (current !== element && inst.onlyZeroWidthSpace(current.textContent) && (!current.firstChild || !inst.isBreak(current.firstChild)) && !current.querySelector(inst._allowedEmptyNodeList)) {\n        if (current.parentNode) {\n          current.parentNode.removeChild(current);\n          return -1;\n        }\n      } else {\n        var children = current.children;\n\n        for (var i = 0, len = children.length, r = 0; i < len; i++) {\n          if (!children[i + r] || inst.isComponent(children[i + r])) continue;\n          r += recursionFunc(children[i + r]);\n        }\n      }\n\n      return 0;\n    })(element);\n\n    if (element.childNodes.length === 0) element.innerHTML = \"<br>\";\n  },\n\n  /**\r\n   * @description Remove whitespace between tags in HTML string.\r\n   * @param {String} html HTML string\r\n   * @returns {String}\r\n   */\n  htmlRemoveWhiteSpace: function htmlRemoveWhiteSpace(html) {\n    if (!html) return \"\";\n    return html.trim().replace(/<\\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)[^>^<]+>\\s+(?=<)/gi, function (m) {\n      return m.trim();\n    });\n  },\n\n  /**\r\n   * @description Sort a element array by depth of element.\r\n   * @param {Array} array Array object\r\n   * @param {Boolean} des true: descending order / false: ascending order\r\n   */\n  sortByDepth: function sortByDepth(array, des) {\n    var t = !des ? -1 : 1;\n    var f = t * -1;\n    array.sort(function (a, b) {\n      if (!this.isListCell(a) || !this.isListCell(b)) return 0;\n      a = this.getElementDepth(a);\n      b = this.getElementDepth(b);\n      return a > b ? t : a < b ? f : 0;\n    }.bind(this));\n  },\n\n  /**\r\n   * @description Nodes that need to be added without modification when changing text nodes\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isIgnoreNodeChange: function _isIgnoreNodeChange(element) {\n    return element && element.nodeType !== 3 && (this.isNonEditable(element) || !this.isTextStyleElement(element));\n  },\n\n  /**\r\n   * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)\r\n   * @param {Node|String} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isMaintainedNode: function _isMaintainedNode(element) {\n    return element && element.nodeType !== 3 && /^(a|label|code)$/i.test(typeof element === \"string\" ? element : element.nodeName);\n  },\n\n  /**\r\n   * @description Node with font-size style\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isSizeNode: function _isSizeNode(element) {\n    return element && element.nodeType !== 3 && this.isTextStyleElement(element) && !!element.style.fontSize;\n  },\n\n  /**\r\n   * @description Nodes without text\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _notTextNode: function _notTextNode(element) {\n    return element && element.nodeType !== 3 && (this.isComponent(element) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof element === \"string\" ? element : element.nodeName));\n  },\n\n  /**\r\n   * @description Check disallowed tags\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _disallowedTags: function _disallowedTags(element) {\n    return /^(meta|script|link|style|[a-z]+\\:[a-z]+)$/i.test(element.nodeName);\n  },\n\n  /**\r\n   * @description Create whitelist RegExp object.\r\n   * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?!\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n   * @param {String} list Tags list (\"br|p|div|pre...\")\r\n   * @returns {RegExp}\r\n   */\n  createTagsWhitelist: function createTagsWhitelist(list) {\n    return new RegExp(\"<\\\\/?\\\\b(?!\\\\b\" + list.replace(/\\|/g, \"\\\\b|\\\\b\") + \"\\\\b)[^>]*>\", \"gi\");\n  },\n\n  /**\r\n   * @description Fix tags that do not fit the editor format.\r\n   * @param {Element} documentFragment Document fragment \"DOCUMENT_FRAGMENT_NODE\" (nodeType === 11)\r\n   * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)\r\n   * @private\r\n   */\n  _consistencyCheckOfHTML: function _consistencyCheckOfHTML(documentFragment, htmlCheckWhitelistRegExp) {\n    /**\r\n     * It is can use \".children(util.getListChildren)\" to exclude text nodes, but \"documentFragment.children\" is not supported in IE.\r\n     * So check the node type and exclude the text no (current.nodeType !== 1)\r\n     */\n    var removeTags = [],\n        emptyTags = [],\n        wrongList = [],\n        withoutFormatCells = []; // wrong position\n\n    var wrongTags = this.getListChildNodes(documentFragment, function (current) {\n      if (current.nodeType !== 1) return false; // white list\n\n      if (!htmlCheckWhitelistRegExp.test(current.nodeName) && current.childNodes.length === 0 && this.isNotCheckingNode(current)) {\n        removeTags.push(current);\n        return false;\n      }\n\n      var nrtag = !this.getParentElement(current, this.isNotCheckingNode); // empty tags\n\n      if (!this.isTable(current) && !this.isListCell(current) && (this.isFormatElement(current) || this.isRangeFormatElement(current) || this.isTextStyleElement(current)) && current.childNodes.length === 0 && nrtag) {\n        emptyTags.push(current);\n        return false;\n      } // wrong list\n\n\n      if (this.isList(current.parentNode) && !this.isList(current) && !this.isListCell(current)) {\n        wrongList.push(current);\n        return false;\n      } // table cells\n\n\n      if (this.isCell(current)) {\n        var fel = current.firstElementChild;\n\n        if (!this.isFormatElement(fel) && !this.isRangeFormatElement(fel) && !this.isComponent(fel)) {\n          withoutFormatCells.push(current);\n          return false;\n        }\n      }\n\n      var result = current.parentNode !== documentFragment && (this.isFormatElement(current) || this.isComponent(current) || this.isList(current)) && !this.isRangeFormatElement(current.parentNode) && !this.isListCell(current.parentNode) && !this.getParentElement(current, this.isComponent) && nrtag;\n      return result;\n    }.bind(this));\n\n    for (var i = 0, len = removeTags.length; i < len; i++) {\n      this.removeItem(removeTags[i]);\n    }\n\n    var checkTags = [];\n\n    for (var _i4 = 0, _len2 = wrongTags.length, t, p; _i4 < _len2; _i4++) {\n      t = wrongTags[_i4];\n      p = t.parentNode;\n      if (!p || !p.parentNode) continue;\n      p.parentNode.insertBefore(t, p);\n      checkTags.push(p);\n    }\n\n    for (var _i5 = 0, _len3 = checkTags.length, _t; _i5 < _len3; _i5++) {\n      _t = checkTags[_i5];\n\n      if (this.onlyZeroWidthSpace(_t.textContent.trim())) {\n        this.removeItem(_t);\n      }\n    }\n\n    for (var _i6 = 0, _len4 = emptyTags.length; _i6 < _len4; _i6++) {\n      this.removeItem(emptyTags[_i6]);\n    }\n\n    for (var _i7 = 0, _len5 = wrongList.length, _t2, tp, children, _p; _i7 < _len5; _i7++) {\n      _t2 = wrongList[_i7];\n      tp = this.createElement(\"LI\");\n      children = _t2.childNodes;\n\n      while (children[0]) {\n        tp.appendChild(children[0]);\n      }\n\n      _p = _t2.parentNode;\n      if (!_p) continue;\n\n      _p.insertBefore(tp, _t2);\n\n      this.removeItem(_t2);\n    }\n\n    for (var _i8 = 0, _len6 = withoutFormatCells.length, _t3, f; _i8 < _len6; _i8++) {\n      _t3 = withoutFormatCells[_i8];\n      f = this.createElement(\"DIV\");\n      f.innerHTML = _t3.textContent.trim().length === 0 && _t3.children.length === 0 ? \"<br>\" : _t3.innerHTML;\n      _t3.innerHTML = f.outerHTML;\n    }\n  },\n  _setDefaultOptionStyle: function _setDefaultOptionStyle(options, defaultStyle) {\n    var optionStyle = \"\";\n    if (options.height) optionStyle += \"height:\" + options.height + \";\";\n    if (options.minHeight) optionStyle += \"min-height:\" + options.minHeight + \";\";\n    if (options.maxHeight) optionStyle += \"max-height:\" + options.maxHeight + \";\";\n    if (options.position) optionStyle += \"position:\" + options.position + \";\";\n    if (options.width) optionStyle += \"width:\" + options.width + \";\";\n    if (options.minWidth) optionStyle += \"min-width:\" + options.minWidth + \";\";\n    if (options.maxWidth) optionStyle += \"max-width:\" + options.maxWidth + \";\";\n    var top = \"\",\n        frame = \"\",\n        editor = \"\";\n    defaultStyle = optionStyle + defaultStyle;\n    var styleArr = defaultStyle.split(\";\");\n\n    for (var i = 0, len = styleArr.length, s; i < len; i++) {\n      s = styleArr[i].trim();\n      if (!s) continue;\n\n      if (/^(min-|max-)?width\\s*:/.test(s) || /^(z-index|position)\\s*:/.test(s)) {\n        top += s + \";\";\n        continue;\n      }\n\n      if (/^(min-|max-)?height\\s*:/.test(s)) {\n        if (/^height/.test(s) && s.split(\":\")[1].trim() === \"auto\") {\n          options.height = \"auto\";\n        }\n\n        frame += s + \";\";\n        continue;\n      }\n\n      editor += s + \";\";\n    }\n\n    return {\n      top: top,\n      frame: frame,\n      editor: editor\n    };\n  },\n  _setIframeDocument: function _setIframeDocument(frame, options) {\n    frame.setAttribute(\"scrolling\", \"auto\");\n    frame.contentDocument.head.innerHTML = \"\" + '<meta charset=\"utf-8\" />' + '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">' + this._setIframeCssTags(options);\n    frame.contentDocument.body.className = options._editableClass;\n    frame.contentDocument.body.setAttribute(\"contenteditable\", true);\n  },\n  _setIframeCssTags: function _setIframeCssTags(options) {\n    var linkNames = options.iframeCSSFileName;\n    var wRegExp = this._w.RegExp;\n    var tagString = \"\";\n\n    for (var f = 0, len = linkNames.length, path; f < len; f++) {\n      path = [];\n\n      if (/(^https?:\\/\\/)|(^data:text\\/css,)/.test(linkNames[f])) {\n        path.push(linkNames[f]);\n      } else {\n        var CSSFileName = new wRegExp(\"(^|.*[\\\\/])\" + linkNames[f] + \"(\\\\..+)?\\\\.css(?:\\\\?.*|;.*)?$\", \"i\");\n\n        for (var c = document.getElementsByTagName(\"link\"), i = 0, _len7 = c.length, styleTag; i < _len7; i++) {\n          styleTag = c[i].href.match(CSSFileName);\n          if (styleTag) path.push(styleTag[0]);\n        }\n      }\n\n      if (!path || path.length === 0) throw '[KothingEditor.constructor.iframe.fail] The KothingEditor CSS files installation path could not be automatically detected. Please set the option property \"iframeCSSFileName\" before creating editor instances.';\n\n      for (var _i9 = 0, _len8 = path.length; _i9 < _len8; _i9++) {\n        tagString += '<link href=\"' + path[_i9] + '\" rel=\"stylesheet\">';\n      }\n    }\n\n    return tagString + (options.height === \"auto\" ? \"<style>\\n/** Iframe height auto */\\nbody{height: min-content; overflow: hidden;}\\n</style>\" : \"\");\n  }\n};\nvar _default = util;\nexports.default = _default;"],
  "mappings": "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",
  "names": []
}
